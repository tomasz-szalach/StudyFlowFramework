-- V7: Partycjonowanie tabeli tasks po task_id (HASH)

-- 1) Nowa tabela partycjonowana
CREATE TABLE IF NOT EXISTS tasks_new (
                                         task_id      bigint  GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                         task_name    varchar(255),
    description  text,
    start_date   date      NOT NULL DEFAULT CURRENT_DATE,
    due_date     date,
    completed_at timestamp,
    reporter_id  bigint,
    task_list_id bigint,
    priority_id  smallint  NOT NULL,
    status_id    smallint  NOT NULL
    ) PARTITION BY HASH (task_id);

-- 2) FK
ALTER TABLE tasks_new
    ADD CONSTRAINT fk_tasks_reporter  FOREIGN KEY (reporter_id)  REFERENCES users(user_id),
    ADD CONSTRAINT fk_tasks_list      FOREIGN KEY (task_list_id) REFERENCES task_lists(task_list_id),
    ADD CONSTRAINT fk_tasks_priority  FOREIGN KEY (priority_id)  REFERENCES priorities(priority_id),
    ADD CONSTRAINT fk_tasks_status    FOREIGN KEY (status_id)    REFERENCES task_statuses(status_id);

-- 3) Indeksy
CREATE INDEX IF NOT EXISTS idx_tasks_new_start_date   ON tasks_new(start_date);
CREATE INDEX IF NOT EXISTS idx_tasks_new_due_date     ON tasks_new(due_date);
CREATE INDEX IF NOT EXISTS idx_tasks_new_priority_id  ON tasks_new(priority_id);
CREATE INDEX IF NOT EXISTS idx_tasks_new_status_id    ON tasks_new(status_id);
CREATE INDEX IF NOT EXISTS idx_tasks_new_task_list_id ON tasks_new(task_list_id);
CREATE INDEX IF NOT EXISTS idx_tasks_new_reporter_id  ON tasks_new(reporter_id);

-- 4) Partycje HASH (4)
CREATE TABLE IF NOT EXISTS tasks_p0 PARTITION OF tasks_new FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE IF NOT EXISTS tasks_p1 PARTITION OF tasks_new FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE IF NOT EXISTS tasks_p2 PARTITION OF tasks_new FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE IF NOT EXISTS tasks_p3 PARTITION OF tasks_new FOR VALUES WITH (MODULUS 4, REMAINDER 3);

-- 5) Przeniesienie danych
INSERT INTO tasks_new
(task_id, task_name, description, start_date, due_date, completed_at,
 reporter_id, task_list_id, priority_id, status_id)
SELECT task_id, task_name, description, start_date, due_date, completed_at,
       reporter_id, task_list_id, priority_id, status_id
FROM tasks
ORDER BY task_id;

-- 6) Zdejmujemy FK z task_members
ALTER TABLE task_members DROP CONSTRAINT IF EXISTS task_members_task_id_fkey;

-- 7) Podmiana tabel
ALTER TABLE tasks RENAME TO tasks_old;
ALTER TABLE tasks_new RENAME TO tasks;

-- 8) Ustaw sekwencję / identity w sposób odporny
DO $$
DECLARE
v_max        bigint;
  seq_name     text;
  is_identity  boolean := false;
BEGIN
SELECT MAX(task_id) INTO v_max FROM public.tasks;
IF v_max IS NULL OR v_max < 1 THEN v_max := 1; END IF;

  -- Czy kolumna jest IDENTITY?
SELECT (a.attidentity IS NOT NULL AND a.attidentity <> '')
INTO is_identity
FROM pg_class t
         JOIN pg_attribute a ON a.attrelid = t.oid AND a.attname = 'task_id'
         JOIN pg_namespace n ON n.oid = t.relnamespace
WHERE t.relname = 'tasks' AND n.nspname = 'public';

-- Nazwa sekwencji (dla SERIAL/DEFAULT i także dla IDENTITY istnieje fizyczna sekwencja)
SELECT pg_get_serial_sequence('public.tasks','task_id') INTO seq_name;

IF seq_name IS NULL THEN
    seq_name := 'public.tasks_task_id_seq';
EXECUTE 'CREATE SEQUENCE IF NOT EXISTS public.tasks_task_id_seq OWNED BY public.tasks.task_id';
END IF;

  -- Ustaw wartość sekwencji na v_max
EXECUTE format('SELECT setval(%L, %s, true)', seq_name, v_max);

IF is_identity THEN
    -- kolumna jest IDENTITY → tylko RESTART WITH
    EXECUTE format('ALTER TABLE public.tasks ALTER COLUMN task_id RESTART WITH %s', v_max + 1);
ELSE
    -- zwykły DEFAULT → ustaw nextval
    EXECUTE format('ALTER TABLE public.tasks ALTER COLUMN task_id SET DEFAULT nextval(%L)', seq_name);
END IF;
END$$;

-- 9) Odtwórz FK
ALTER TABLE task_members
    ADD CONSTRAINT task_members_task_id_fkey
        FOREIGN KEY (task_id) REFERENCES tasks(task_id) ON DELETE CASCADE;

-- 10) Trigger audytu
DROP TRIGGER IF EXISTS trg_audit_tasks ON tasks;
CREATE TRIGGER trg_audit_tasks
    AFTER INSERT OR UPDATE OR DELETE ON tasks
    FOR EACH ROW EXECUTE FUNCTION audit.log_with_pk('task_id');

-- 11) Sprzątanie
DROP TABLE IF EXISTS tasks_old;
